# Native Read View Research

## 1. Read Page Data Display Analysis

### Main UI Components:
1. **Header/Toolbar Area**
   - Focus mode toggle
   - Quick Set Status Mode option
   - All Other menus items placed in our FAB

2. **Audio Control Section** *(Only visible when audio is present)*
   - Playback controls (â—€ â–¶)
   - Time indicators (0:00 0:00)
   - Speed controls (3 sec, 5 sec, 10 sec, 30 sec, 60 sec)
   - Playback rate controls (- 1.0 +)

3. **Main Reading Content Area**
   - Text content organized in paragraphs or segments
   - Interactive elements marked with symbols like âœ” â€º and âœ” âœ”
   - Celebration indicator (ðŸŽ‰) (only on final page)

4. **Navigation/Footer Area**
   - Page navigation (1/1)

### JavaScript Configuration Variables:
- `lang_is_rtl`: Controls right-to-left language display
- `book_id`: Identifies the current book
- `page_num`: Current page number
- `page_count`: Total pages in the book
- `highlights`: Boolean flag for text highlighting
- `track_page_open`: Page tracking setting
- `book_audio`: Audio file for the book
- `book_audio_current_pos`: Current audio position
- `book_audio_bookmarks`: Audio bookmarks

## 2. Server Endpoint Analysis

### Core Reading Endpoints
- **`GET /read/<bookid>`** - Load initial book reading page
- **`GET /read/<bookid>/page/<pagenum>`** - Load specific page content
- **`GET /read/<bookid>/peek/<pagenum>`** - Preview page without tracking
- **`POST /read/page_done`** - Mark page as read
- **`POST /read/save_player_data`** - Save audio player data

### Term Management Endpoints
- **`GET,POST /read/termform/<langid>/<text>`** - Create/edit multiword term
- **`GET,POST /read/edit_term/<term_id>`** - Edit existing term
- **`GET /term/search/<term>/<langid>`** - Search for terms (used in parent term lookup)

### Bookmark Endpoints
- **`GET /bookmarks/<bookid>`** - List bookmarks for a book
- **`POST /bookmarks/add`** - Add new bookmark
- **`POST /bookmarks/delete/<bookmarkid>`** - Delete bookmark

### Anki Integration Endpoints
- **`POST /term/create_anki_card/<termid>`** - Create Anki card for term
- **`POST /term/create_anki_cards_for_text`** - Create Anki cards for selected text

### Translation Endpoints
- **`POST /translate`** - Translate text
- **`GET /translate/settings`** - Get translation settings

### Settings Endpoints
- **`GET /settings/index`** - Get user settings (needed for theme, audio settings, etc.)
- **`POST /settings/set/<key>/<value>`** - Update specific settings
- **`GET /theme/current`** - Get current theme CSS
- **`GET /theme/custom_styles`** - Get custom CSS styles

### Language Endpoints
- **`GET /language/index`** - List languages (for language-specific features)
- **`GET /language/edit/<langid>`** - Get language details

### Book Endpoints
- **`GET /book/edit/<bookid>`** - Get book details (for metadata display)
- **`POST /book/archive/<bookid>`** - Archive book
- **`POST /book/delete/<bookid>`** - Delete book

### Page Management Endpoints
- **`POST /read/start_reading/<bookid>/<pagenum>`** - Begin reading page
- **`GET /read/refresh_page/<bookid>/<pagenum>`** - Refresh page content
- **`POST /read/add_page/<bookid>/<position>`** - Add new page
- **`POST /read/delete_page/<bookid>/<pagenum>`** - Delete page

### Status Update Endpoints
- **`POST /term/update_status/<termid>/<status>`** - Update term status
- **`POST /term/update_statuses`** - Bulk update term statuses

## 3. Existing Native Components Integration

### NativeTermFormFragment Integration

#### When to Show NativeTermFormFragment:
- When user taps on a word/term in the reading text
- When user selects "Create new term" from menu
- When user selects "Edit term" from menu or context action

#### Integration Points:
- **Text Interaction**: NativeTextView components will detect taps on terms
- **Data Passing**:
  - Pass term text, language ID, and context to NativeTermFormFragment
  - Pass existing term data when editing
- **Callback Handling**:
  - Implement DictionaryListener interface in NativeReadFragment
  - Handle save/cancel actions from the term form
  - Update UI with any term status changes

#### Data Flow:
```
NativeTextView (term tap)
    â†“
NativeReadFragment (detects tap, extracts term data)
    â†“
NativeTermFormFragment.newInstance() (with term data)
    â†“
NativeTermFormFragment (displays form)
    â†“ [User actions]
NativeReadFragment (via DictionaryListener callbacks)
    â†“ [Save/Edit actions]
ReadViewModel (sends updates to server)
    â†“
Server (via /read/edit_term/<term_id> or /read/termform/<langid>/<text>)
```

### DictionaryFragment Integration

#### When to Show DictionaryFragment:
- When user taps dictionary button in NativeTermFormFragment
- When user selects "Translate sentence" or "Translate page" from menu

#### Integration Points:
- **Dictionary Lookup Trigger**:
  - NativeTermFormFragment calls dictionaryListener.onDictionaryLookup(term)
  - NativeReadFragment implements DictionaryListener and shows DictionaryFragment
- **Text Synchronization**:
  - DictionaryFragment calls dictionaryListener.onDictionaryTextSelected(text)
  - NativeReadFragment updates NativeTermFormFragment with selected text
- **Closing Dictionary**:
  - DictionaryFragment calls dictionaryListener.onDictionaryClosed()
  - NativeReadFragment hides DictionaryFragment and shows NativeTermFormFragment

#### Data Flow:
```
NativeTermFormFragment (dictionary button tap)
    â†“
DictionaryListener.onDictionaryLookup(term)
    â†“
NativeReadFragment (shows DictionaryFragment)
    â†“
DictionaryFragment (loads dictionary entries)
    â†“ [User selects text]
DictionaryListener.onDictionaryTextSelected(text)
    â†“
NativeReadFragment (updates NativeTermFormFragment)
    â†“ [User closes dictionary]
DictionaryListener.onDictionaryClosed()
    â†“
NativeReadFragment (hides DictionaryFragment)
```

### Shared Components and Data

#### TranslationCacheManager
- Used by both NativeTermFormFragment and DictionaryFragment
- Maintains temporary translation text during dictionary lookups
- Ensures consistency between the two components

#### TermData and TermFormData
- Shared data classes between components
- TermData: Represents term information received from JavaScript interface
- TermFormData: Represents form data for term creation/editing

#### Server Communication
- Both components use ServerSettingsManager to get server URL
- Both components make direct HTTP requests to server endpoints
- ReadViewModel will also handle some server communication for reading features

### Interface Implementation

#### NativeReadFragment Implementation of DictionaryListener:
```kotlin
class NativeReadFragment : Fragment(), NativeTermFormFragment.DictionaryListener {
    override fun onDictionaryLookup(term: String) {
        // Show DictionaryFragment with term
    }

    override fun onDictionaryTextSelected(text: String) {
        // Update currently shown NativeTermFormFragment with text
    }

    override fun onDictionaryClosed() {
        // Hide DictionaryFragment
    }
}
```

## 4. Mobile-Specific Considerations

### Touch Interaction Design
- **Gesture Support**:
  - Tap to select words/terms
  - Long press for context menus
  - Swipe gestures for page navigation
  - Pinch-to-zoom for text scaling (if supported)
- **Touch Targets**:
  - Ensure all interactive elements meet minimum touch target size (48dp)
  - Provide adequate spacing between controls
  - Implement proper hit area padding for small controls

### Screen Size and Orientation Handling
- **Responsive Layout**:
  - Adaptable layouts for different screen sizes (phones, tablets)
  - Portrait and landscape orientation support
  - Dynamic reflow of text content based on available space
- **Multi-window Support**:
  - Proper handling when app is in split-screen mode
  - Adjust layouts and text rendering for reduced screen space

### Performance Optimization
- **Memory Management**:
  - Efficient text rendering for large content
  - Bitmap caching for static UI elements
  - Proper recycling of views in lists (e.g., bookmark lists)
- **Battery Usage**:
  - Optimize audio playback (use foreground services)
  - Minimize background network requests
  - Efficient handling of animations and transitions

### Network Resilience
- **Offline Support**:
  - Cache text content for offline reading
  - Local storage of bookmarks and reading progress
  - Queue network requests for retry when connectivity is restored
- **Connection Handling**:
  - Graceful degradation when server is unreachable
  - Clear error messaging for network issues
  - Automatic retry mechanisms for failed requests

### Audio Playback Considerations
- **Background Playback**:
  - Implement as foreground service to prevent killing
  - Proper notification integration with playback controls
  - Handle audio focus changes (calls, other media)
- **Battery Optimization**:
  - Efficient audio streaming
  - Wakelock management during playback
  - Optimize for different device power management settings

### UI/UX Mobile-Specific Features
- **Immersive Reading**:
  - Full-screen mode option
  - Adjustable brightness/night mode
  - Customizable text appearance (font, size, spacing)
- **Navigation**:
  - System bar hiding in reading mode
  - Back button handling for different screens
  - Proper implementation of Android's predictive back gesture

### Accessibility
- **Screen Reader Support**:
  - Proper content descriptions for all UI elements
  - Logical reading order for screen readers
  - Support for accessibility services
- **Text Scaling**:
  - Respect system text scaling settings
  - Maintain layout integrity with larger text
  - Custom text scaling options within the app

### Security and Permissions
- **Required Permissions**:
  - Internet access for server communication
  - Audio playback permissions
  - Storage access for caching (if needed)
- **Data Protection**:
  - Secure storage of user data
  - Proper handling of authentication tokens (if applicable)
  - Network security (HTTPS, certificate validation)

### Platform Integration
- **System Features**:
  - Integration with Android's sharing system
  - Support for external keyboards
  - Handle system dark mode settings
- **Notification Integration**:
  - Reading progress notifications
  - Audio playback notifications
  - Reminder notifications for daily reading goals

### Device-Specific Considerations
- **Hardware Differences**:
  - Different screen densities and resolutions
  - Various processor capabilities
  - Device-specific performance characteristics
- **Android Version Support**:
  - Backward compatibility with older Android versions
  - Use of modern APIs where available
  - Graceful fallback for unsupported features

## 5. Implementation Plan

### Core Architecture

#### Main Components:
1. **NativeReadFragment** - Main container fragment
2. **ReadViewModel** - Central data management
3. **ReadRepository** - Data access layer
4. **TextRenderer** - Text content processing and rendering
5. **AudioPlayerManager** - Audio playback coordination *(Only active when audio is present)*
6. **NavigationController** - Page navigation logic
7. **BookStateManager** - Manages book state and persistence
8. **TermInteractionManager** - Manages term selection and interaction

#### Data Flow:
```
NativeReadFragment (UI)
    â†“â†‘
ReadViewModel (State Management)
    â†“â†‘
ReadRepository (Data Access)
    â†“â†‘
Server API (Lute Endpoints)
```

### Component Implementation Details

#### NativeReadFragment
- **Responsibilities**:
  - Host all UI components
  - Handle lifecycle events
  - Implement DictionaryListener interface
  - Coordinate between components
  - Handle FAB menu interactions
  - Manage book state persistence
  - Handle term interaction events
- **Key Methods**:
  - `onCreateView()` - Initialize UI
  - `onViewCreated()` - Setup component interactions
  - `onDictionaryLookup()` - Show DictionaryFragment
  - `onDictionaryTextSelected()` - Update NativeTermFormFragment
  - `onDictionaryClosed()` - Hide DictionaryFragment
  - `onFabMenuItemSelected()` - Handle FAB menu actions
  - `saveCurrentBookState()` - Save current book ID and page
  - `loadLastBookState()` - Load last read book ID and page
  - `onTermSingleTap(term)` - Handle single tap on term
  - `onTermDoubleTap(term)` - Handle double tap on term

#### ReadViewModel
- **Responsibilities**:
  - Manage reading state (current page, book info, etc.)
  - Handle data fetching and processing
  - Coordinate with repository for server communication
  - Expose LiveData for UI updates
  - Manage book state transitions
  - Handle term interaction state
- **Key Methods**:
  - `loadBookPage(bookId, pageNum)` - Fetch page content
  - `updateTermStatus(termId, status)` - Update term status
  - `saveReadingProgress()` - Save page/audio progress
  - `getTextContent()` - Expose processed text content
  - `createAnkiCard(termId)` - Create Anki card for term
  - `setCurrentBook(bookId)` - Set current book and save state
  - `loadLastBook()` - Load the last read book
  - `translateTerm(term)` - Get translation for term
  - `getTermDetails(termId)` - Get detailed term information

#### ReadRepository
- **Responsibilities**:
  - Direct communication with Lute server
  - Handle HTTP requests/responses
  - Parse server responses
  - Manage caching strategies
- **Key Methods**:
  - `fetchPageContent(bookId, pageNum)` - GET /read/<bookid>/page/<pagenum>
  - `savePageProgress(data)` - POST /read/page_done
  - `saveAudioProgress(data)` - POST /read/save_player_data
  - `updateTermStatus(termId, status)` - POST /term/update_status/<termid>/<status>
  - `createAnkiCard(termId)` - POST /term/create_anki_card/<termid>
  - `fetchTermTranslation(term, langId)` - POST /translate
  - `fetchTermDetails(termId)` - GET /read/edit_term/<term_id>

#### TextRenderer
- **Responsibilities**:
  - Parse HTML text content from server
  - Convert to native text segments
  - Handle interactive elements (terms, status indicators)
  - Manage text styling and formatting
- **Key Methods**:
  - `parseHtmlContent(html)` - Process HTML to text segments
  - `renderTextSegments(container)` - Render segments in UI container
  - `updateSegmentStatus(segmentId, status)` - Update visual status
  - `highlightSelectedTerm(term)` - Visually highlight selected term

#### AudioPlayerManager *(Only active when audio is present)*
- **Responsibilities**:
  - Coordinate audio playback
  - Manage audio player service
  - Handle playback controls
  - Track and save position
- **Key Methods**:
  - `initializePlayer(audioFile)` - Setup audio playback
  - `play()/pause()/stop()` - Control playback
  - `seekTo(position)` - Navigate to position
  - `saveCurrentPosition()` - Save position to server

#### NavigationController
- **Responsibilities**:
  - Manage page navigation
  - Handle pagination logic
  - Coordinate with ViewModel
- **Key Methods**:
  - `goToPage(pageNum)` - Navigate to specific page
  - `nextPage()/previousPage()` - Page navigation
  - `getCurrentPageInfo()` - Get current page details

#### BookStateManager
- **Responsibilities**:
  - Persist book reading state (book ID, page number)
  - Load last read book state on app start
  - Update state when new books are opened
- **Key Methods**:
  - `saveCurrentBookState(bookId, pageNum)` - Save current book state
  - `loadLastBookState()` - Load last book state
  - `clearBookState()` - Clear saved book state

#### TermInteractionManager
- **Responsibilities**:
  - Handle term selection and interaction
  - Manage single tap vs double tap logic
  - Show translation popups
  - Trigger NativeTermForm display
- **Key Methods**:
  - `onTermTapped(term)` - Handle term tap events
  - `showTranslationPopup(term, translation)` - Display translation popup
  - `showTermForm(termData)` - Display NativeTermForm
  - `clearSelection()` - Clear current term selection

### UI Component Structure

#### Layout Hierarchy:
```
NativeReadFragment
â”œâ”€â”€ ToolbarFragment (Top)
â”‚   â”œâ”€â”€ FocusModeToggle
â”‚   â””â”€â”€ QuickSetStatusToggle
â”œâ”€â”€ AudioPlayerFragment (Top) *(Only visible when audio is present)*
â”‚   â”œâ”€â”€ PlaybackControls
â”‚   â”œâ”€â”€ TimeIndicators
â”‚   â”œâ”€â”€ SpeedControls
â”‚   â””â”€â”€ PlaybackRateControls
â”œâ”€â”€ ScrollView (Main Content)
â”‚   â””â”€â”€ TextContentView (Custom ViewGroup)
â”‚       â”œâ”€â”€ TextSegment (multiple)
â”‚       â””â”€â”€ InteractiveElements
â”œâ”€â”€ TranslationPopup (Overlay) *(Shown on single tap)*
â””â”€â”€ PageIndicatorFragment (Bottom)
    â”œâ”€â”€ PageNavigation
    â””â”€â”€ PageCounter
```

#### FAB Menu Integration:
- Use existing FAB for all menu actions
- Menu items will include:
  - List bookmarks
  - Add bookmark
  - Create Anki cards
  - Translate sentence
  - Translate page
  - Toggle highlights
  - Text formatting options

#### Term Interaction Flow:
```
User taps term
    â†“
TermInteractionManager.onTermTapped(term)
    â†“
If first tap on term â†’ Show translation popup + highlight term
    â†“
If second tap on same term â†’ Show NativeTermForm
    â†“
If tap on different term â†’ Clear previous selection, show translation popup + highlight new term
    â†“
If tap elsewhere â†’ Clear selection
```

### Server Endpoint Usage Map

| Component | Endpoint | Purpose |
|-----------|----------|---------|
| ReadRepository | GET /read/<bookid>/page/<pagenum> | Fetch page content |
| ReadRepository | POST /read/page_done | Save page progress |
| ReadRepository | POST /read/save_player_data | Save audio progress |
| ReadRepository | POST /term/update_status/<termid>/<status> | Update term status |
| ReadRepository | GET /bookmarks/<bookid> | Load bookmarks |
| ReadRepository | POST /bookmarks/add | Add bookmark |
| ReadRepository | POST /term/create_anki_card/<termid> | Create Anki card |
| ReadRepository | POST /translate | Translate text |
| ReadRepository | GET /read/edit_term/<term_id> | Get term details |
| AudioPlayerManager | GET /read/<bookid> | Get audio file info |
| MenuManager | POST /read/add_page/<bookid>/<position> | Add new page |
| MenuManager | POST /read/delete_page/<bookid>/<pagenum> | Delete page |

### Book State Management

#### State Persistence:
- Use SharedPreferences to store:
  - Last read book ID
  - Last read page number
  - Reading position in book
- Load state when fragment is created
- Save state when:
  - User navigates to a different page
  - User opens a different book
  - Fragment is paused/stopped

#### State Transition Logic:
```
App Start
    â†“
Load Last Book State
    â†“
If state exists â†’ Load book and page
    â†“
If no state or book deleted â†’ Navigate to book selection
    â†“
User opens new book
    â†“
Save current book state
    â†“
Load new book content
```

### Term Interaction Implementation Details

#### Single Tap Behavior:
1. Visually highlight the tapped term (background color change, underline, or border)
2. Show a small translation popup below or above the term
3. Popup should automatically dismiss after a few seconds or when user taps elsewhere
4. Tapping the same term again should not show the popup again (unless it was dismissed)

#### Double Tap Behavior:
1. If user taps the same term twice in quick succession (or with a slight delay), show the NativeTermForm
2. The NativeTermForm should be displayed as a dialog/fragment
3. The term should remain highlighted while the form is open

#### Visual Selection Feedback:
- Use a subtle but noticeable highlight (e.g., light background color or border)
- Ensure the highlight is visible on different background colors
- Consider using a slightly different font weight or adding an underline
- The highlight should be cleared when:
  - User taps a different term
  - User taps elsewhere on the screen
  - User scrolls the content significantly
  - NativeTermForm is displayed

### Implementation Phases

#### Phase 1: Core Reading Functionality
- Basic text rendering
- Page navigation
- Book state persistence
- Simple term highlighting

#### Phase 2: Term Interaction
- Single tap translation popup
- Double tap NativeTermForm display
- Visual selection feedback
- Term highlighting

#### Phase 3: Audio Integration *(Only when audio is present)*
- Audio player implementation
- Playback controls
- Position tracking

#### Phase 4: Advanced Features
- Bookmark management
- Translation tools
- Anki integration (via FAB menu)
- Highlight toggling

#### Phase 5: Polish and Optimization
- Performance tuning
- UI refinement
- Bug fixes
- Accessibility improvements
